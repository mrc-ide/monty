// Generated by scripts/update_monty_math - do not edit
#pragma once

#include <cmath>
#include <limits>

#include "monty/random/cuda_compatibility.hpp"

// https://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__SINGLE.html
// https://stackoverflow.com/a/39409957

namespace monty {
namespace math {

// Automatically generated functions; see scripts/update_monty_math in
// the monty source repo
template <typename T>
__host__ __device__
T round(T x) {
  return std::round(x);
}

template <typename real_type>
__host__ __device__
  real_type round(int x) {
  return std::round(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float round(float x) {
  return ::roundf(x);
}
#endif

template <typename T>
__host__ __device__
T ceil(T x) {
  return std::ceil(x);
}

template <typename real_type>
__host__ __device__
  real_type ceil(int x) {
  return std::ceil(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float ceil(float x) {
  return ::ceilf(x);
}
#endif

template <typename T>
__host__ __device__
T floor(T x) {
  return std::floor(x);
}

template <typename real_type>
__host__ __device__
  real_type floor(int x) {
  return std::floor(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float floor(float x) {
  return ::floorf(x);
}
#endif

template <typename T>
__host__ __device__
T trunc(T x) {
  return std::trunc(x);
}

template <typename real_type>
__host__ __device__
  real_type trunc(int x) {
  return std::trunc(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float trunc(float x) {
  return ::truncf(x);
}
#endif

template <typename T>
__host__ __device__
T sqrt(T x) {
  return std::sqrt(x);
}

template <typename real_type>
__host__ __device__
  real_type sqrt(int x) {
  return std::sqrt(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float sqrt(float x) {
  return ::sqrtf(x);
}
#endif

template <typename T>
__host__ __device__
T exp(T x) {
  return std::exp(x);
}

template <typename real_type>
__host__ __device__
  real_type exp(int x) {
  return std::exp(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float exp(float x) {
  return ::expf(x);
}
#endif

template <typename T>
__host__ __device__
T expm1(T x) {
  return std::expm1(x);
}

template <typename real_type>
__host__ __device__
  real_type expm1(int x) {
  return std::expm1(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float expm1(float x) {
  return ::expm1f(x);
}
#endif

template <typename T>
__host__ __device__
T log(T x) {
  return std::log(x);
}

template <typename real_type>
__host__ __device__
  real_type log(int x) {
  return std::log(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float log(float x) {
  return ::logf(x);
}
#endif

template <typename T>
__host__ __device__
T log2(T x) {
  return std::log2(x);
}

template <typename real_type>
__host__ __device__
  real_type log2(int x) {
  return std::log2(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float log2(float x) {
  return ::log2f(x);
}
#endif

template <typename T>
__host__ __device__
T log10(T x) {
  return std::log10(x);
}

template <typename real_type>
__host__ __device__
  real_type log10(int x) {
  return std::log10(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float log10(float x) {
  return ::log10f(x);
}
#endif

template <typename T>
__host__ __device__
T log1p(T x) {
  return std::log1p(x);
}

template <typename real_type>
__host__ __device__
  real_type log1p(int x) {
  return std::log1p(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float log1p(float x) {
  return ::log1pf(x);
}
#endif

template <typename T>
__host__ __device__
T erf(T x) {
  return std::erf(x);
}

template <typename real_type>
__host__ __device__
  real_type erf(int x) {
  return std::erf(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float erf(float x) {
  return ::erff(x);
}
#endif

template <typename T>
__host__ __device__
T erfc(T x) {
  return std::erfc(x);
}

template <typename real_type>
__host__ __device__
  real_type erfc(int x) {
  return std::erfc(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float erfc(float x) {
  return ::erfcf(x);
}
#endif

template <typename T>
__host__ __device__
T tgamma(T x) {
  return std::tgamma(x);
}

template <typename real_type>
__host__ __device__
  real_type tgamma(int x) {
  return std::tgamma(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float tgamma(float x) {
  return ::tgammaf(x);
}
#endif

template <typename T>
__host__ __device__
T cos(T x) {
  return std::cos(x);
}

template <typename real_type>
__host__ __device__
  real_type cos(int x) {
  return std::cos(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float cos(float x) {
  return ::cosf(x);
}
#endif

template <typename T>
__host__ __device__
T sin(T x) {
  return std::sin(x);
}

template <typename real_type>
__host__ __device__
  real_type sin(int x) {
  return std::sin(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float sin(float x) {
  return ::sinf(x);
}
#endif

template <typename T>
__host__ __device__
T tan(T x) {
  return std::tan(x);
}

template <typename real_type>
__host__ __device__
  real_type tan(int x) {
  return std::tan(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float tan(float x) {
  return ::tanf(x);
}
#endif

template <typename T>
__host__ __device__
T acos(T x) {
  return std::acos(x);
}

template <typename real_type>
__host__ __device__
  real_type acos(int x) {
  return std::acos(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float acos(float x) {
  return ::acosf(x);
}
#endif

template <typename T>
__host__ __device__
T asin(T x) {
  return std::asin(x);
}

template <typename real_type>
__host__ __device__
  real_type asin(int x) {
  return std::asin(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float asin(float x) {
  return ::asinf(x);
}
#endif

template <typename T>
__host__ __device__
T atan(T x) {
  return std::atan(x);
}

template <typename real_type>
__host__ __device__
  real_type atan(int x) {
  return std::atan(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float atan(float x) {
  return ::atanf(x);
}
#endif

template <typename T>
__host__ __device__
T cosh(T x) {
  return std::cosh(x);
}

template <typename real_type>
__host__ __device__
  real_type cosh(int x) {
  return std::cosh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float cosh(float x) {
  return ::coshf(x);
}
#endif

template <typename T>
__host__ __device__
T sinh(T x) {
  return std::sinh(x);
}

template <typename real_type>
__host__ __device__
  real_type sinh(int x) {
  return std::sinh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float sinh(float x) {
  return ::sinhf(x);
}
#endif

template <typename T>
__host__ __device__
T tanh(T x) {
  return std::tanh(x);
}

template <typename real_type>
__host__ __device__
  real_type tanh(int x) {
  return std::tanh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float tanh(float x) {
  return ::tanhf(x);
}
#endif

template <typename T>
__host__ __device__
T acosh(T x) {
  return std::acosh(x);
}

template <typename real_type>
__host__ __device__
  real_type acosh(int x) {
  return std::acosh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float acosh(float x) {
  return ::acoshf(x);
}
#endif

template <typename T>
__host__ __device__
T asinh(T x) {
  return std::asinh(x);
}

template <typename real_type>
__host__ __device__
  real_type asinh(int x) {
  return std::asinh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float asinh(float x) {
  return ::asinhf(x);
}
#endif

template <typename T>
__host__ __device__
T atanh(T x) {
  return std::atanh(x);
}

template <typename real_type>
__host__ __device__
  real_type atanh(int x) {
  return std::atanh(static_cast<real_type>(x));
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float atanh(float x) {
  return ::atanhf(x);
}
#endif

template <typename T>
__host__ __device__
T atan2(T x, T y) {
  return std::atan2(x, y);
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float atan2(float x, float y) {
  return ::atan2f(x, y);
}
#endif

// Functions written by hand because they don't generalise usefully

// Special beacuse we nee
template <typename T, typename U>
__host__ __device__
T pow(T x, U y) {
  return std::pow(x, y);
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float pow(float x, float y) {
  return ::powf(x, y);
}

template <>
__device__
inline float pow(float x, int y) {
  // could possibly use fast power here (see binomial.hpp)
  return ::powf(x, static_cast<float>(y));
}
#endif

// Special because name does not follow pattern:
template <typename T>
__host__ __device__
T abs(T x) {
  return std::abs(x);
}

#ifdef __CUDA_ARCH__
template <>
__device__
inline float abs(float x) {
  return ::fabsf(x);
}
#endif

template <typename T>
__host__ __device__
T min(T a, T b) {
  return a < b ? a : b;
}

template <typename T>
__host__ __device__
T max(T a, T b) {
  return a > b ? a : b;
}

template <typename real_type>
__host__ __device__ real_type lgamma(real_type x) {
  static_assert(std::is_floating_point<real_type>::value,
                "lgamma should only be used with real types");
  return std::lgamma(x);
}

#ifdef __CUDA_ARCH__
template <>
inline __device__ float lgamma(float x) {
  return ::lgammaf(x);
}

template <>
inline __device__ double lgamma(double x) {
  return ::lgamma(x);
}
#endif

template <typename real_type>
__host__ __device__
real_type lfactorial(int x) {
  return lgamma(static_cast<real_type>(x + 1));
}

template <typename T>
__host__ __device__
T lbeta(T a, T b) {
  return lgamma(a) + lgamma(b) - lgamma(a + b);
}

template <typename T>
__host__ __device__
T beta(T a, T b) {
  return exp(lbeta(a, b));
}

// We can do this (more efficiently!) with copysign, but end up with
// having a bit of fight with different overloads.  This way is fine.
//
// https://stackoverflow.com/questions/1903954/is-there-a-standard-sign-function-signum-sgn-in-c-c
// https://en.cppreference.com/w/cpp/numeric/math/copysign
template <typename T>
__host__ __device__
T sign(T x) {
  return (T(0) < x) - (x < T(0));
}

}
}
