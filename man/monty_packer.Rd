% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packer.R
\name{monty_packer}
\alias{monty_packer}
\title{Build a parameter packer}
\usage{
monty_packer(scalar = NULL, array = NULL, fixed = NULL, process = NULL)
}
\arguments{
\item{scalar}{Names of scalar parameters.  This is similar for
listing elements in \code{array} with values of 1, though elements in
\code{scalar} will be placed ahead of those listed in \code{array} within
the final parameter vector, and elements in \code{array} will have
generated names that include square brackets.}

\item{array}{A list, where names correspond to the names of array
parameters and values correspond to the lengths of parameters.
Multiple dimensions are allowed (so if you provide an element
with two entries these represent dimensions of a matrix).
Zero-length integer vectors or \code{NULL} values are counted as
scalars, which allows you to put scalars at positions other than
the front of the packing vector. In future, you may be able to
use \emph{strings} as values for the lengths, in which case these
will be looked for within \code{fixed}.}

\item{fixed}{A named list of fixed parameters; these will be added
into the final list directly.  These typically represent
additional pieces of data that your model needs to run, but
which you are not performing inference on.}

\item{process}{An arbitrary R function that will be passed the
final assembled parameter list; it may create any \emph{additional}
entries, which will be concatenated onto the original list.  If
you use this you should take care not to return any values with
the same names as entries listed in \code{scalar}, \code{array} or
\code{fixed}, as this is an error (this is so that \code{pack()} is
not broken).  We will likely play around with this process in
future in order to get automatic differentiation to work.}
}
\value{
An object of class \code{monty_packer}, which has three
elements:
\itemize{
\item \code{parameters}: a character vector of computed parameter names;
these are the names that your statistical model will use.
\item \code{unpack}: a function that can unpack an unstructured vector
(say, from your statistical model parameters) into a structured
list (say, for your generative model)
\item \code{pack}: a function that can pack your structured list of
parameters back into a numeric vector suitable for the
statistical model.  This ignores values created by a
\code{preprocess} function.
\item \code{index}: a function which produces a named list where each
element has the name of a value in \code{parameters} and each value
has the indices within an unstructured vector where these values
can be found.
\item \code{subset}: an experimental interface which can be used to subset a
packer to a packer for a subset of contents. Documentation will
be provided once the interface settles.
}
}
\description{
Build a parameter packer, which can be used in models to translate
between an unstructured vector of numbers (the vector being
updated by an MCMC for example) to a structured list of named
values, which is easier to program against.  We refer to the
process of taking a named list of scalars, vectors and arrays and
converting into a single vector "packing" and the inverse
"unpacking".
}
\details{
There are several places where it is most convenient to work in an
unstructured vector:
\itemize{
\item An MCMC is typically discussed as a the updating of some
vector \code{x} to another \verb{x'}
\item An optimisation algorithm will try and find a set of values for
a vector \code{x} that minimises (or maximises) some function \code{f(x)}
\item An ode solver works with a vector \code{x(t)} (\code{x} at time \code{t}) and
considers \code{x(t + h)} by computing the vector of derivatives
\code{dx(t)/dt}
}

In all these cases, the algorithm that needs the vector of numbers
knows nothing about what they represent.  Commonly, these will be
a packed vector of parameters.  So our vector \code{x} might actually
represent the parameters \code{a}, \code{b} and \code{c} in a vector as \verb{[a, b, c]} - this is a very common pattern, and you have probably
implemented this yourself.

In more complex settings, we might want our vector \code{x} to collect
more structured quantities.  Suppose that you are fitting a model
with an age-structured or sex-structured parameter.  Rather than
having a series of scalars packed into your vector \code{x} you might
have a series of values destined to be treated as a vector:

\if{html}{\out{<div class="sourceCode">}}\preformatted{| 1  2  3  4  5  6  7  |
| a  b  c  d1 d2 d3 d4 |
}\if{html}{\out{</div>}}

So here we might have a vector of length 7, where the first three
elements will represent be the scalar values \code{a}, \code{b} and \code{c} but
the next four will be a vector \code{d}.

Unpacked, this might be written as:

\if{html}{\out{<div class="sourceCode">}}\preformatted{list(a = 1, b = 2, c = 3, d = 4:7)
}\if{html}{\out{</div>}}

The machinery here is designed to make these transformations
simple and standardised within monty, and should be flexible
enough for many situations.  We will also use these from within
\code{dust2} and \code{odin2} for transformations in and out of vectors of
ODE state.
}
\section{When to use \code{process}}{
The \code{process} function is a get-out-of-jail function designed to
let you do arbitrary transformations when unpacking a vector.  In
general, this should not be the first choice to use because it is
less easy to reason about by other tooling (for example, as we
develop automatic differentiation support for use with the HMC
algorithm, a \code{process} function will be problematic because we
will need to make sure we can differentiate this process).
However, there are cases where it will be only way to achieve some
results.

Imagine that you are packing a 2x2 covariance matrix into your
vector in order to use within an MCMC or optimisation algorithm.
Ultimately, our unpacked vector will need to hold four elements
(\code{b11}, \code{b12}, \code{b21}, \code{b22}), but there are only three distinct
values as the two off-diagonal elements will be the same (i.e.,
\code{b12 == b21}).  So we might write this passing in \code{b_raw = 3} to
\code{array}, so that our unpacked list holds \code{b_raw = c(b11, b12, b22)}.  We would then write \code{process} as something like:

\if{html}{\out{<div class="sourceCode">}}\preformatted{process <- function(x) \{
  list(b = matrix(x$b_raw[c(1, 2, 2, 3)], 2, 2))
\}
}\if{html}{\out{</div>}}

which creates the symmetric 2x2 matrix \code{b} from \code{b_raw}.
}

\section{Unpacking matrices}{
If you do not use \code{fixed} or \code{process} when defining your packer,
then you can use \verb{$unpack()} with a matrix or higher-dimensional
output.  There are two ways that you might like to unpack this
sort of output.  Assume you have a matrix \code{m} with 3 rows and 2
columns; this means that we have two sets of parameters or state
(one per column) and 3 states within each; this is the format that
MCMC parameters will be in for example.

The first would to be return a list where the \code{i}th element is the
result of unpacking the \code{i}th parameter/state vector.  You can do
this by running

\if{html}{\out{<div class="sourceCode">}}\preformatted{apply(m, 2, p$unpack)
}\if{html}{\out{</div>}}

The second would be to return a named list with three elements
where the \code{ith} element is the unpacked version of the \code{i}th
state.  In this case you can pass the matrix directly in to the
unpacker:

\if{html}{\out{<div class="sourceCode">}}\preformatted{p$unpack(m)
}\if{html}{\out{</div>}}

When you do this, the elements of \code{m} will acquire an additional
dimension; scalars become vectors (one per set), vectors become
matrices (one column per set) and so on.

This approach generalises to higher dimensional input, though we
suspect you'll spend a bit of time head-scratching if you use it.
}

\section{Packing lists into vectors and matrices}{
The unpacking operation is very common - an MCMC proceeds,
produces an unstructured vector, and you unpack it into a list in
order to be able to easily work with it.  The reverse is much less
common, where we take a list and convert it into a vector (or
matrix, or multidimensional array).  Use of this direction
("packing") may be more common where using packers to work with
the output of state-space models (e.g. in
\href{https://mrc-ide.github.io/odin2}{odin2} or
\href{https://mrc-ide.github.io/dust2}{dust2}, which use this
machinery).

The input to \code{pack()} will be the shape that \code{unpack()} returned;
a named list of numerical vectors, matrices and arrays.  The names
must correspond to the names in your packer (i.e., \code{scalar} and
the names of \code{array}).  Each element has dimensions

\if{html}{\out{<div class="sourceCode">}}\preformatted{<...object, ...residual>
}\if{html}{\out{</div>}}

where \code{...object} is the dimensions of the data itself and
\code{...residual} is the dimensions of the hypothetical input to
\code{pack}.

There is an unfortunate ambiguity in R's lack of true scalar types
that we cannot avoid.  It is hard to tell the difference packing a
vector vs packing an array where all dimensions are 1.  See the
examples, and please let us know if the behaviour needs changing.
}

\examples{
# Here's a really simple example
p <- monty_packer(c("a", "b", "c"))
p

p$pack(list(a = 1, b = 2, c = 3))
p$unpack(1:3)

# Sometimes we have a vector embedded in our parameters:
p <- monty_packer(c("a", "b"), list(v = 4))
p$pack(list(a = 1, b = 2, v = c(6, 7, 8, 9)))
p$unpack(c(1, 2, 6, 7, 8, 9))

# Or a higher dimensional structure such as a matrix:
p <- monty_packer(c("a", "b"), list(m = c(2, 2)))
p$unpack(c(1, 2, 6, 7, 8, 9))

# You can use a packer to set "fixed" parameters that do not vary
# with the underlying model being fit, but are required by your model.
# This is simpler than the "closure" approach used previously in our
# mcstate package and also easier to accommodate with differentiable
# models:
p <- monty_packer(
  c("a", "b"),
  fixed = list(d = data.frame(n = 1:3, m = runif(3))))
p$unpack(1:2)
p$pack(p$unpack(1:2))

# The example from above, where we create a symmetric 2 x 2 matrix
# from a 3-element vector, alongside a scalar:
p <- monty_packer(
  scalar = "a",
  array = list(b_flat = 3),
  process = function(p) list(b = matrix(p$b_flat[c(1, 2, 2, 3)], 2, 2)))

# Unpacking we see "b_flat" is still in the list, but "b" is our
# symmetric matrix:
p$unpack(1:4)

# The processed elements are ignored on the return pack:
p$pack(list(a = 1, b_flat = 2:4, b = matrix(c(2, 3, 3, 4), 2, 2)))
p$pack(list(a = 1, b_flat = 2:4))

# R lacks scalars, which means that some packers will unpack
# different inputs to the same outputs:
p <- monty_packer(c("a", "b"))
p$unpack(1:2)
p$unpack(cbind(1:2))

# This means that we can't reliably pack these inputs in a way
# that guarantees round-tripping is possible.  We have chosen to
# prioritise the case where a *single vector* is round-trippable:
p$pack(list(a = 1, b = 2))

# This ambiguity goes away if unpacking matices with more than one
# column:
p$unpack(matrix(1:6, 2, 3))
}
