% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampler-parallel-tempering.R
\name{monty_sampler_parallel_tempering}
\alias{monty_sampler_parallel_tempering}
\title{Parallel Tempering Sampler}
\usage{
monty_sampler_parallel_tempering(
  sampler,
  n_rungs = NULL,
  beta = NULL,
  base = NULL
)
}
\arguments{
\item{sampler}{A sampler to use for the underlying chains.  You
might use something like \code{monty_sampler_random_walk(vcv)} for a
random walk sampler embedded in this parallel tempering scheme.}

\item{n_rungs}{The number of \strong{extra} chains to run, must be at
least 1.  We will run a total of \code{n_rungs + 1} chains, with one
of these being your target distribution and one being a direct
sample from your base model (often your prior).}

\item{beta}{A vector of beta values.  If provided, then \code{n_rungs}
should not be provided, and \code{beta} should be a vector of at
least length 2, where the first value is 1, the last value is 0
and the values in between form a strictly decreasing sequence
(i.e., no increases, no ties).}

\item{base}{An optional base model, which must be provided if your
model cannot be automatically decomposed into \code{prior + posterior} using \link{monty_model_split}, or if you are not using
this within a Bayesian context and you want to use an
alternative easy-to-sample-from reference distribution.  We
require that this model can be directly sampled from, that it
accepts multiple parameters (as a matrix), that it is
deterministic and we assume that it is cheap to compute
(relative to the target).}
}
\value{
A \code{monty_sampler} object, which can be used with
\link{monty_sample}
}
\description{
Create a "parallel tempering" sampler, which runs multiple chains
at once to try and improve mixing, or takes advantage of
vectorisation/parallelisation if your underlying model supports
it.  We have tested the implementation with the random walk
sampler (\link{monty_sampler_random_walk}) but this may work with other
samplers.
}
\details{
We implement the sampler based on \url{https://doi.org/10.1111/rssb.12464}
}
\section{Efficiency of the sampler}{
A parallel tempering sampler runs a series of chains at the same
time, so is doing much more work than a simpler sampler.  If you
run with \code{n_rungs = 10} you are doing 11x more work than the
underlying base sampler, so you want to make sure that this is
paid back somewhere.  There are a few places where this efficiency
may come from:
\enumerate{
\item \strong{Your model is parallelisable}.  If your underlying model can
run very efficiently in parallel then it may not take much longer
in "wall time" to run the extra copies of the calculations.  In
this case, you'll still be using much more CPU time but will be
able to take advantage of extra cores to get more effective
sampling if the parallel tempering sampler mixes better than the
underlying sampler.
\item \strong{Your model is vectorised}.  If your model is implemented in
R and vectorises the density calculations then it will generally
not take much longer to compute many densities at once than a
single one.
\item \strong{Your density is multimodal}.  If your density has distinct
peaks, then most samplers will struggle to explore it well, and
even with a non-parallelised, non-vectorised sampler the parallel
tempering sampler will explore the space more efficiently.  In the
limit, a normal sampler may only explore a single peak in a model
with many such peaks and will never mix properly.
}
}

\section{Tuning the beta values}{
The argument \code{beta} controls the spacing of temperature among
chains.  Ideally, this is set so that adjacent chains all have the
same probability of swapping, which generally means that the
\code{beta} values themselves will \emph{not} be equidistant.  Creating the
appropriate vector of betas (or "annealing schedule") requires
running a pilot run, then computing new \code{beta} values, then
running another (new) chain with the new beta values, repeating
this iteration a few times until the beta values stabilise.
Rumour has it, this should only take a few iterations.

The updated values of \code{beta} are stored in the \code{details} of your
samples after running.  So if you have a set of samples called
\code{s}, then \code{s$details$beta} will contain new beta values that you
can use on the next run.

It is important not to concatenate chains that are computed with
different \code{beta} values as they will not generally represent
samples from the target distribution (as an extreme case, consider
one set of beta values where we never accept swaps onto the target
distribution and another where we always do; we obviously cannot
concatenate these).  Therefore, every time that you change beta
values you should start a new chain.  You can do this with
\link{monty_sample_continue} so long as you pass \code{append = FALSE}.
}

