% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampler.R
\name{monty_sampler2}
\alias{monty_sampler2}
\title{Create a monty sampler}
\usage{
monty_sampler2(
  name,
  help,
  control,
  initialise,
  step,
  state_dump = NULL,
  state_restore = NULL
)
}
\arguments{
\item{name}{Name of the sampler. Usually this is the name of the
algorithm and can include spaces and punctuation if desired.}

\item{help}{Name of the function to direct users to find help.
Usually that is the name of the constructor function.}

\item{control}{A list of control parameters passed to the sampler.
These are immutable (i.e., once created they cannot be changed).}

\item{initialise}{A function to initialise the sampler.  This is
called once at the start of the chain to set up any internal
state, though in some cases it will not need to do very much.
It must take arguments:
\itemize{
\item \code{state_chain}: the state of the MCMC chain (TODO: describe)
\item \code{control}: the control parameters, as originally passed to
\code{monty_sampler2}
\item \code{model}: the model being sampled from
\item the random number generator state, which the sampler may draw
from.
}

Return \code{NULL} if your sampler is stateless, otherwise return an
environment (e.g., created with \code{new.env(parent = emptyenv())}
of state that will be updated at each iteration.  You can store
whatever is convenient in this, for example a random walk
sampler might store the eigendecomposition of a variance
covariance matrix used in the proposal here.}

\item{step}{The workhorse function of a sampler, propagating state
(the pair (parameters, density)) forward one step in the chain.
Typically, but not always, this will include a proposal,
evaluation of a density, and an acceptance.

It must take arguments:
\itemize{
\item \code{state_chain}: The state of the MCMC chain (as above)
\item \code{state_sampler}: The state of the sampler, as passed back from
\code{init}.  If your sampler is stateless this is \code{NULL},
otherwise it is an environment that you will modify by
reference.
\item \code{control}: Sampler control parameters (as above)
\item \code{model}: The model (as above)
\item \code{rng}: The random number state, which you can use in the step
(as above)
}

Return \code{state_chain}, updated after acceptance.}

\item{state_dump}{Optionally, a function to prepare the chain
state for serialisation.  If not given, we assume that
\code{as.list()} is sufficient and use that (unless your state is
\code{NULL}, in which case we use \code{identity}).  If provided then
typically you will need to provide \code{state_restore}, too.}

\item{state_restore}{Optionally, a function to take a dumped chain
state and convert it back into an environment.  If not given, we
assume that \code{list2env(x, parent = emptyenv())} is sufficient and
use that (unless your state is \code{NULL}, in which case we use
\code{identity}).  If provided then typically you will need to
provide \code{state_dump}, too.  The arguments here, if provided,
must be
\itemize{
\item \code{state_chain}
\item \code{state_sampler}
\item \code{control}
\item \code{model}
}}
}
\value{
A \code{monty_sampler2} object
}
\description{
A \code{monty_sampler2} object can be passed into \code{monty_sample} in
order to draw samples from a distribution.  Samplers are stateful
objects that can mutate the state of a markov chain and advance
the MCMC one step.  Ordinarily users will not call this function,
but authors of samplers will call it from the constructor of their
sampler.
}
\details{
See \code{vignette("writing-samplers")} for an introduction to writing
samplers.

Control parameters are used to build the sampler.  These are
immutable after creation.  The format is unspecified by
\code{monty_sampler2} but typically this will be a named list.  The
sampler designer will construct this list and should take care not
to include anything mutable (e.g. environments) or hard to
serialise and transfer to another process here.
}
